\documentclass[11pt]{article}
\title{Linear Model Simulations: Canonical IV DGP}
\author{Kellie Ottoboni}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx,float}
\usepackage[margin=0.75in]{geometry}
\usepackage{bm}
\usepackage[backend=bibtex]{biblatex}
\usepackage{hyperref}
\setlength{\parindent}{0cm}

\begin{document}

\maketitle
<<chunk1, echo=FALSE, results ='hide', message=F, warning=F>>=
library(knitr)
library(xtable)
library(ModelMatch)
library(reshape2)
library(ggplot2)
opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, results = 'hide', cache=FALSE)
@

Suppose

\begin{align*}
Y_i &= \beta X_i + \epsilon_i \\
T_i &= \mathbb{I}(U_i + \delta_i > 0)
\end{align*}

where $(U_i, X_i, \epsilon_i, \delta_i)$ are IID multivariate normal with mean $0$ across individuals $i = 1,\dots, N$.  For each $i$, we take the three objects $X_i$, $U_i$, and $(\epsilon_i, \delta_i)$ to be mutually independent. Suppose further that

\begin{align*}
\text{Var}(U_i) = \text{Var}(X_i) &= 1 \\
\text{Var}(\epsilon_i) = \text{Var}(\delta_i) &= \sigma^2 \\
\text{Cov}(\epsilon_i, \delta_i) &= \rho
\end{align*}

Estimate $\hat{Y}$ using OLS on $X$. \\

<<setparameters>>=
set.seed(321)
B <- 5000
N <- 100
@

We have $N=$\Sexpr{N} individuals.  Suppose we use two strata, defined by whether $\hat{Y} \geq 0$ or $\hat{Y} < 0$.  \\

We'll do the model-based matching permutation test using the difference in means as our statistic \Sexpr{B} times to get a distribution of p-values under the null hypothesis of no treatment effect. The simulations are done \textbf{conditionally on $X$ and $\epsilon$}: we draw $X$ and $\epsilon$ once to generate the potential outcomes $Y$, then draw random $U$ and $\delta$ to generate treatment $T$ for each simulation.

<<simulation_function>>=
simulate <- function(N, beta=1, sigma2=1, rho=0, B = 1000, fit_correctly = TRUE){
  # Simulate strata with nonconstant propensity scores. No treatment effect
  # N = number of individuals
  # beta = coefficient of X in DPG for Y (default 1)
  # sigma2 = variance of errors epsilon and delta (default 1)
  # rho = covariance between errors epsilon and delta (default 0)
  # B  = number of simulations. Default 1000
  # fit_correctly = indicator for how to model Y. If TRUE (default), fit Y~X1+X2. Otherwise, fit Y~X2.

  
  X <- rnorm(N)
  epsilon <- rnorm(N, sd = sqrt(sigma2))
  Y = beta*X + epsilon
  
  Yhat <- lm(Y~X)$fitted
  stratum <- ifelse(Yhat >= 0, 1, 2)

  pvalues <- matrix(NA, nrow = B, ncol = 2)
  colnames(pvalues) <- c("Model-based Matching", "Unadjusted Permutation Test")
  for(b in 1:B){
    U <- rnorm(N)
    delta <- (rho*epsilon + sqrt(1-rho^2)*rnorm(N))*sqrt(sigma2)

    Tr <- 1*(U+delta > 0)

    strata_list <- list(
    data.frame("index" = which(stratum == 1),
               "score" = Yhat[stratum == 1],
               "treatment" = Tr[stratum == 1]
               ),
    data.frame("index" = which(stratum == 2),
               "score" = Yhat[stratum == 2],
               "treatment" = Tr[stratum == 2]
               )
    )
  
    res <- permu_test_mean(strata = strata_list, prediction = Yhat, treatment = Tr,
                    response = Y)
    pvalues[b, 1] <- res$pvalue["twosided"]
    
    single_stratum <- list(do.call(rbind, strata_list))
    res2 <- permu_test_mean(strata = single_stratum, prediction = 0, treatment = Tr,
                    response = Y)
    pvalues[b, 2] <- res2$pvalue["twosided"]
    
  }

  return(pvalues)
}
@

<<plot_function>>=
compute_power <- function(pvalues){
  sapply((0:99)/100, function(p) mean(pvalues <= p, na.rm = TRUE))
}

plot_power_curves <- function(pvalues){
  # Input ``pvalues'' should be the output of simulate
  power_curves <- apply(pvalues, 2, compute_power)
  power_curves <- data.frame(cbind(power_curves,
                              "alpha" = (0:99)/100))
  power_curves_plot <- melt(power_curves, id.vars = "alpha", value.name = "power")
  ggplot(power_curves_plot, aes(x = alpha, y = power, color = variable)) +
    geom_line() +
    xlab("Significance level") +
    ylab("Pr(Reject Null)") +
    theme(legend.position = "bottom")
  }
@


\section{Uncorrelated errors}


<<simulate1, fig.align="center", fig.width=6, fig.height=6>>=
res1 <- simulate(N = N, beta = 1, sigma2 = 1, rho = 0, B = B)
plot_power_curves(res1) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  ggtitle("Uncorrelated Errors")

@

<<sim1_tab, results="asis">>=

prop_reject <- apply(res1, 2, function(x) mean(x<=0.05))

print(xtable(data.frame(prop_reject[2:1]),
      caption = "Proportion of tests rejected at level 0.05",
      digits = 3),
      include.rownames = TRUE,
      include.colnames = FALSE)
@

\section{Correlated errors}
Here, we let $N = 100$, $\beta = 1$, $\sigma^2 = 1$, and $\rho = 3/4$.

<<simulate2, fig.align="center", fig.width=6, fig.height=6>>=
res2 <- simulate(N = N, beta = 1, sigma2 = 1, rho = 0.75, B = B)
plot_power_curves(res2) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  ggtitle("Correlated Errors")

@

<<sim2_tab, results="asis">>=

prop_reject2 <- apply(res2, 2, function(x) mean(x<=0.05))

print(xtable(data.frame(prop_reject2[2:1]),
      caption = "Proportion of tests rejected at level 0.05",
      digits = 3),
      include.rownames = TRUE,
      include.colnames = FALSE)
@

\end{document}
